<!DOCTYPE html>

<html class="dark" lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Moderation Queue View</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&amp;display=swap"
        rel="stylesheet" />
    <link
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap"
        rel="stylesheet" />
    <link
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap"
        rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#215bed",
                        "primary-glow": "#215bed",
                        "background-light": "#f6f6f8",
                        "background-dark": "#101522",
                        "glass-border": "rgba(255, 255, 255, 0.08)",
                        "glass-surface": "rgba(20, 25, 40, 0.7)",
                        "success": "#0bda62",
                        "danger": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Inter", "sans-serif"]
                    },
                    borderRadius: { "DEFAULT": "0.5rem", "lg": "1rem", "xl": "1.5rem", "2xl": "2rem", "full": "9999px" },
                    backdropBlur: {
                        'xs': '2px',
                    }
                },
            },
        }
    </script>
    <style>
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a3040;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3b4254;
        }

        .glass-panel {
            background: rgba(30, 35, 50, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .glass-card {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        .glass-card:hover {
            border-color: rgba(33, 91, 237, 0.3);
            box-shadow: 0 10px 40px -10px rgba(33, 91, 237, 0.15);
        }

        /* Ambient glow background */
        .ambient-glow {
            position: absolute;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(33, 91, 237, 0.15) 0%, rgba(0, 0, 0, 0) 70%);
            top: -100px;
            right: -100px;
            pointer-events: none;
            z-index: 0;
        }

        .ambient-glow-2 {
            position: absolute;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(11, 218, 98, 0.08) 0%, rgba(0, 0, 0, 0) 70%);
            bottom: -100px;
            left: -100px;
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>

<body
    class="bg-background-dark text-white font-display h-screen w-full overflow-hidden flex selection:bg-primary selection:text-white">
    <!-- Sidebar Navigation -->
    <aside id="admin-sidebar"
        class="hidden md:flex w-20 lg:w-72 flex-shrink-0 h-full flex-col justify-between border-r border-glass-border bg-[#111318]/90 z-20 relative">
        <!-- Sidebar will be injected here -->
    </aside>

    <!-- Main Content Area -->
    <main class="flex-1 flex flex-col relative z-10 overflow-hidden bg-background-dark">
        <!-- Background Effects -->
        <div class="ambient-glow"></div>
        <div class="ambient-glow-2"></div>

        <!-- Sticky Header -->
        <header
            class="flex-shrink-0 px-6 py-5 lg:px-10 flex flex-col gap-6 z-20 backdrop-blur-sm bg-background-dark/30 sticky top-0 border-b border-glass-border">
            <div class="flex items-start justify-between">
                <div class="flex items-center gap-3">
                    <button id="mobile-menu-btn" onclick="toggleSidebar()" class="md:hidden text-white p-2 -ml-2 mr-2">
                        <span class="material-symbols-outlined">menu</span>
                    </button>
                    <div>
                        <h2 class="text-3xl font-black tracking-tight text-white mb-1">Moderation Queue</h2>
                        <p class="text-gray-400 text-sm">Reviewing pending user submissions for compliance.</p>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="loadPendingPosts()"
                        class="glass-card size-10 rounded-lg flex items-center justify-center text-gray-300 hover:text-white hover:bg-white/5 transition-colors">
                        <span class="material-symbols-outlined text-[20px]">refresh</span>
                    </button>
                </div>
            </div>

            <div class="flex flex-col lg:flex-row gap-6 items-start lg:items-center justify-between">
                <div class="flex gap-4 w-full lg:w-auto overflow-x-auto pb-2 lg:pb-0 no-scrollbar">
                    <div
                        class="glass-panel px-5 py-3 rounded-xl flex items-center gap-4 min-w-[160px] border-l-4 border-l-primary">
                        <div class="flex flex-col">
                            <span class="text-xs text-gray-400 uppercase font-semibold tracking-wider">Pending</span>
                            <span class="text-2xl font-bold text-white" id="pending-count">...</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Scrollable Grid Content -->
        <div class="flex-1 overflow-y-auto px-6 lg:px-10 py-6 pb-20 custom-scrollbar">
            <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-6" id="moderation-grid">
                <!-- Posts will be loaded here -->
            </div>
        </div>
    </main>

    <script src="../js/config.js"></script>
    <script src="../js/utils.js"></script>
    <script src="../js/post_utils.js"></script>
    <script src="../js/site_branding.js"></script>
    <script src="../js/admin_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            renderAdminSidebar('moderation');
            loadPendingPosts();
        });

        let currentPage = 1;
        let lastPage = 1;
        let isFetchingQueue = false;

        async function loadPendingPosts(page = 1) {
            if(isFetchingQueue) return;
            isFetchingQueue = true;
            currentPage = page;

            const grid = document.getElementById('moderation-grid');
            const container = document.querySelector('main'); // For scrolling to top
            if(!grid) { isFetchingQueue = false; return; }

            const cacheKey = 'moderation_queue_cache';
            
            // 1. Initial Cache Load (Optimization for Instant Load)
            const cached = localStorage.getItem(cacheKey);
            // Only use cache on initial load (page 1) to avoid confusing pagination mixed states
            if (page === 1 && cached && grid.innerHTML.trim() === '') {
                try {
                    const parsed = JSON.parse(cached);
                    let posts = [];
                    // Handle both new paginated object and old array formats
                    if (parsed.items && Array.isArray(parsed.items)) {
                        posts = parsed.items;
                    } else if (Array.isArray(parsed)) {
                        posts = parsed;
                    }

                    if (posts.length > 0) {
                        renderPendingPosts(posts);
                        const total = parsed.pagination ? parsed.pagination.total : posts.length;
                        document.getElementById('pending-count').textContent = total;
                        if(parsed.pagination) renderPaginationControls(parsed.pagination);
                    }
                } catch(e) { console.error("Cache parse error", e); }
            }

            try {
                const response = await fetch(`${API_BASE_URL}/pending_posts?page=${page}`, {
                    credentials: 'include'
                });

                if(handleAdminApiError(response)) return;

                const data = await response.json();
                
                // Update UI based on new standardized response structure (wrapped in 'items')
                // data.data is now possibly { items: [...], pagination: {...} } OR direct array depending on how backend sends it. 
                // Since user used paginateData helper, response structure is usually data.data.items and data.data.pagination
                
                let posts = [];
                let pagination = null;

                if (data.success) {
                    if (data.data.items) {
                         posts = data.data.items;
                         pagination = data.data.pagination;
                    } else if (Array.isArray(data.data)) {
                        posts = data.data; // Fallback if regular get() was used
                    }

                    if (pagination) {
                        lastPage = pagination.last_page;
                    }
                    
                    // SAVE TO CACHE (Only page 1)
                    if (page === 1) {
                         // Save the whole data object (items + pagination) or just items depending on what we want.
                         // For simplicity, save data.data which contains both in the new structure
                         localStorage.setItem(cacheKey, JSON.stringify(data.data));
                    }

                    renderBulkActions(posts.length > 0);
                    
                    if (posts.length > 0) {
                        renderPendingPosts(posts);
                        document.getElementById('pending-count').textContent = pagination ? pagination.total : posts.length;
                        renderPaginationControls(pagination);
                    } else {
                        grid.innerHTML = `<div class="col-span-full py-20 text-center text-slate-500">
                            <span class="material-symbols-outlined text-4xl mb-2">check_circle</span>
                            <p>No pending posts to review. Excellent work!</p>
                        </div>`;
                        document.getElementById('pending-count').textContent = '0';
                        renderPaginationControls(null);
                    }
                } else {
                     grid.innerHTML = `<div class="col-span-full py-20 text-center text-slate-500">
                        <span class="material-symbols-outlined text-4xl mb-2">check_circle</span>
                        <p>No pending posts to review. Excellent work!</p>
                    </div>`;
                    document.getElementById('pending-count').textContent = '0';
                }
            } catch (e) {
                console.error(e);
                 grid.innerHTML = `<div class="col-span-full py-20 text-center text-red-500">Error loading moderation queue.</div>`;
            } finally {
                isFetchingQueue = false;
            }
        }

        function renderBulkActions(hasPosts) {
            const headerActions = document.querySelector('header .flex.items-center.gap-3:last-child');
            // Remove existing bulk buttons if any
            const existingBulk = document.getElementById('bulk-actions');
            if(existingBulk) existingBulk.remove();

            if(!hasPosts) return;

            // Only add if user is Admin/SuperAdmin (Frontend check visual only)
            // Ideally check roles here, but assuming access is handled by page access
            
            const btnContainer = document.createElement('div');
            btnContainer.id = 'bulk-actions';
            btnContainer.className = 'flex gap-2 mr-2';
            btnContainer.innerHTML = `
                <button onclick="confirmBulkAction('reject')" class="h-10 px-4 rounded-lg bg-danger/10 hover:bg-danger text-danger hover:text-white border border-danger/20 transition-all flex items-center gap-2 font-medium text-sm">
                    <span class="material-symbols-outlined text-[18px]">delete_sweep</span> Reject All
                </button>
                <button onclick="confirmBulkAction('approve')" class="h-10 px-4 rounded-lg bg-success/10 hover:bg-success text-success hover:text-white border border-success/20 transition-all flex items-center gap-2 font-medium text-sm">
                    <span class="material-symbols-outlined text-[18px]">done_all</span> Approve All
                </button>
            `;
            
            // Insert before the Refresh button container
            headerActions.insertBefore(btnContainer, headerActions.firstChild);
        }

        async function confirmBulkAction(type) {
             const result = await Swal.fire({
                title: `Are you sure?`,
                text: `This will ${type} ALL pending posts in the system. This cannot be undone!`,
                icon: 'warning',
                showCancelButton: true,
                confirmButtonColor: type === 'approve' ? '#0bda62' : '#ef4444',
                cancelButtonColor: '#3085d6',
                confirmButtonText: `Yes, ${type} them!`,
                background: '#1e2332',
                color: '#fff'
            });

            if (result.isConfirmed) {
                performBulkAction(type);
            }
        }

        async function performBulkAction(type) {
            const endpoint = type === 'approve' ? 'approve_all_post' : 'reject_all_post';
            try {
                Swal.fire({ title: 'Processing...', didOpen: () => Swal.showLoading(), background: '#1e2332', color: '#fff' });
                
                const response = await fetch(`${API_BASE_URL}/${endpoint}`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    Swal.fire({
                        title: 'Success!',
                        text: data.message,
                        icon: 'success',
                        background: '#1e2332',
                        color: '#fff'
                    });
                    loadPendingPosts(1); // Reload from page 1
                } else {
                    Swal.fire({ title: 'Error', text: data.message, icon: 'error', background: '#1e2332', color: '#fff' });
                }
            } catch (error) {
                console.error(error);
                Swal.fire({ title: 'Error', text: 'Server connection failed', icon: 'error', background: '#1e2332', color: '#fff' });
            }
        }

        function renderPaginationControls(pagination) {
            const gridContainer = document.querySelector('.custom-scrollbar'); // The scrollable dev
            const existingPagination = document.getElementById('pagination-controls');
            if(existingPagination) existingPagination.remove();

            if(!pagination || pagination.total_pages <= 1) return;

            const footer = document.createElement('div');
            footer.id = 'pagination-controls';
            footer.className = 'py-6 px-10 flex items-center justify-between border-t border-glass-border mt-4 mb-20'; // mb-20 for bottom space
            
            const prevDisabled = pagination.current_page === 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-white/5 cursor-pointer';
            const nextDisabled = pagination.current_page === pagination.last_page ? 'opacity-50 cursor-not-allowed' : 'hover:bg-white/5 cursor-pointer';

            footer.innerHTML = `
                <div class="text-sm text-gray-400">
                    Showing <span class="text-white font-medium">${pagination.from}</span> to <span class="text-white font-medium">${pagination.to}</span> of <span class="text-white font-medium">${pagination.total}</span> results
                </div>
                <div class="flex items-center gap-2">
                    <button ${pagination.current_page === 1 ? 'disabled' : ''} onclick="loadPendingPosts(${pagination.current_page - 1})" class="glass-card px-4 py-2 rounded-lg text-sm text-gray-300 transition-colors ${prevDisabled}">
                        Previous
                    </button>
                    <span class="glass-card px-4 py-2 rounded-lg text-sm text-white bg-white/5">
                        Page ${pagination.current_page} of ${pagination.last_page}
                    </span>
                    <button ${pagination.current_page === pagination.last_page ? 'disabled' : ''} onclick="loadPendingPosts(${pagination.current_page + 1})" class="glass-card px-4 py-2 rounded-lg text-sm text-gray-300 transition-colors ${nextDisabled}">
                        Next
                    </button>
                </div>
            `;
            
            // Append after the grid inside the scroll container, or just after the main content div
             // Since the direct parent of moderation-grid is the scrollable div
             const gridParent = document.getElementById('moderation-grid').parentElement;
             gridParent.appendChild(footer);
        }

        function renderPendingPosts(posts) {
            const grid = document.getElementById('moderation-grid');
            grid.innerHTML = '';

            posts.forEach(post => {
                const author = post.user || {};
                const avatar = author.profile?.avatar
                    ? `${PUBLIC_URL}/${author.profile.avatar}`
                    : `https://ui-avatars.com/api/?name=${encodeURIComponent(author.name)}&background=215bed&color=fff`;

                const timeAgo = getTimeAgo(post.created_at);
                const mediaHtml = post.image
                    ? `<div class="relative aspect-video w-full bg-black/50 overflow-hidden">
                         <img src="${PUBLIC_URL}/${post.image}" class="absolute inset-0 w-full h-full object-cover">
                       </div>`
                    : '';

                grid.innerHTML += `
                    <div class="glass-card rounded-2xl flex flex-col overflow-hidden group/card relative" id="post-${post.id}">
                        <div class="p-4 flex items-center gap-3 border-b border-glass-border bg-white/[0.02]">
                            <img src="${avatar}" class="size-10 rounded-full object-cover bg-slate-700" onerror="this.src='https://ui-avatars.com/api/?name=${author.name}&background=215bed&color=fff'">
                            <div class="flex flex-col">
                                <span class="text-sm font-semibold text-white">@${author.name || 'user'}</span>
                                <span class="text-xs text-gray-500">Reputation: Neutral</span>
                            </div>
                            <span class="ml-auto text-xs text-gray-500">${timeAgo}</span>
                        </div>
                        <div class="flex-1 flex flex-col">
                            ${mediaHtml}
                            <div class="p-4">
                                <p class="text-sm text-gray-300 leading-relaxed">${post.body || ''}</p>
                            </div>
                        </div>
                        <div class="p-4 mt-auto flex gap-3 border-t border-glass-border bg-white/[0.02]">
                            <button onclick="handleModeration(${post.id}, 'reject')" class="flex-1 group/btn flex items-center justify-center gap-2 bg-danger/10 hover:bg-danger text-danger hover:text-white h-11 rounded-xl transition-all duration-200 border border-danger/20 hover:border-danger">
                                <span class="material-symbols-outlined text-[20px]">close</span>
                                <span class="font-medium">Reject</span>
                            </button>
                            <button onclick="handleModeration(${post.id}, 'approve')" class="flex-1 group/btn flex items-center justify-center gap-2 bg-success/10 hover:bg-success text-success hover:text-white h-11 rounded-xl transition-all duration-200 border border-success/20 hover:border-success">
                                <span class="material-symbols-outlined text-[20px]">check</span>
                                <span class="font-medium">Approve</span>
                            </button>
                        </div>
                    </div>
                `;
            });
        }

        async function handleModeration(postId, action) {
            const endpoint = action === 'approve' ? 'approve_post' : 'reject_post';
            try {
                const response = await fetch(`${API_BASE_URL}/${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ id: postId })
                });
                const data = await response.json();
                if (data.success) {
                    const card = document.getElementById(`post-${postId}`);
                    card.style.opacity = '0.5';
                    card.style.pointerEvents = 'none';
                    setTimeout(() => {
                        card.remove();
                        // Optional: decrease pending count manually or reload
                        const countEl = document.getElementById('pending-count');
                        const count = parseInt(countEl.textContent);
                        if (!isNaN(count)) countEl.textContent = count - 1;
                        
                        // Check if grid is empty, if so, reload current page to fetch logic again
                        const grid = document.getElementById('moderation-grid');
                        if(grid.children.length === 0 && lastPage > 1) {
                            loadPendingPosts(currentPage);
                        }
                    }, 300);
                    showToast(`Post ${action}d successfully`,'success');
                } else {
                    showToast('Action failed: ' + data.message, 'error');
                }
            } catch (e) {
                console.error(e);
                showToast('Server error.', 'error');
            }
        }

        function getTimeAgo(dateString) {
            const now = new Date();
            const then = new Date(dateString);
            const seconds = Math.floor((now - then) / 1000);
            if (seconds < 60) return 'Just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            return `${Math.floor(hours / 24)}d ago`;
        }
    </script>
</body>

</html>